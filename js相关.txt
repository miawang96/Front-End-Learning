1.何为非阻塞方式下载js文件？（和56点相呼应）
a.js文件的加载方式
--使用<script>标签内联到HTML页面
--使用<script>标签的src属性引入外部的js文件

注：并行下载并不意味着并行执行（我们要确保的是执行的正确顺序）

b.非阻塞加载外部脚本
--XHR Eval
使用XMLHTTPRequest对象从服务器异步获取js脚本文件，当响应完成后使用eval函数对响应内容进行执行。

--XHR Injection
将异步获取的内容使用动态创建script标签的形式插入到DOM元素中去。

--Script in IFrame
将需要加载的js脚本放入一个html文件中然后使用iframe非阻塞加载这个html文件即可

--Script DOM Element
通过js脚本动态创建script标签到DOM中，可以动态设置src属性，并且可以是不同域名下的js文件

--Script Defer（仅适用于IE浏览器）
IE浏览器的script标签支持defer属性，表示浏览器不会立即下载这个script标签对应的js文件

2.何为闭包？（浅谈js中的闭包）=> 结合面试题
首先：变量作用域
js作用域的特殊之处：函数内部可以读取全局变量
声明变量时注意：如果在函数内部声明变量不用var，该变量会变成全局变量
链式作用域：父对象的所有变量，对子对象都是可见的，反之则不成立。
总结性概念：闭包就是可以读取其他函数内部变量的函数/函数内部的函数
闭包的用途：可以读取函数的内部变量；让这些变量的值始终保存在内存中

使用闭包注意点：闭包使得函数中的变量长时间存储在内存中，会造成资源浪费
在退出函数之间，将不使用的局部变量全部删除;
会随便改变父函数内部变量的值

3.何为重绘和回流？

重绘：渲染树的元素外观发生改变但不影响布局时，会发生重绘
回流：渲染树的元素布局发生改变时，会引起重绘回流
回流一定会引起重绘，但是重绘不一定会引起回流

4.何为Layout属性值？

5.作用域与变量声明提升？
作用域：为function(){}内的区域，称为函数作用域
变量声明提升：函数声明与变量声明经常被提升到当前作用域的顶部

6.Angular（新版本）和AngularJS（老版本）之间的关系？
Angular1是典型的MVC架构
Angualr2是基于组件的架构（基本是推到重来）
Angular2 与 Angular1.x完全不同，最基本的语法都不一样，Angular1.x是基于javascript,
而Angualr2是基于TypeScript的框架

8.何为TypeScript
TypeScript是一种由微软开发的自由和开源的编程语言。
它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。

9.何为作用域链（例子理解）  类似于原型链
a)全局函数无法查看局部函数的全部细节，但局部函数可以查看其上层的函数细节，直至全局细节
b)如果当前作用域没有找到属性或方法，会向上层作用域查找，直至全局函数，这种形式就是作用域链

10.对this对象的理解
a)对于函数，this 指向调用该函数的对象
b)对于事件，this指向触发该事件的对象
c)对于 new 方法，this指向被创建出来的实例对象
d)IE下attachEvent中的this指向全局对象Window

11.复述HTML文档中都有哪些节点
文档节点：整个文档
元素节点：每个HTML元素
文本节点：HTML元素内的文本
属性节点：每个HTML属性
注释节点：注释
根节点：Document对象是HTML文档的根节点

12.事件的三个阶段
捕获阶段、目标阶段、冒泡阶段
浏览器总是假定click事件的目标节点为嵌套最深的那个节点

13.写一个完整的HTML文档的结构
<!DOCTYPE html>
  <head>
    <title></title>
  </head>
  <body></body>
</html>

14.如何引用JQuery库
下载JQuery库 -> 在HTML的<script>标签中引用它
JQuery版本有两种：
Production version - 用于实际的网站中，已被精简和压缩
Development version - 用于测试和开发，代码可读

15.HTML5新增元素特性（**熟悉使用**）
HTML5是对HTML标准的第五次修订
a.文件类型声明仅有一型：<!DOCTYPE HTML>
b.新的解析顺序，不再基于SGML
c.新的元素：section,video,progress,nav,meter,time,aside,canvas,command,datalist,details,embed,figcaption,figure
	    footer,header,hgroup,keygen,mark,output,rp,rt,ruby,source,summary,wbr
d.input元素的新类型:date,email,url等
e.新的属性:ping（用于a与area）,charset（用于meta），async（用于script）
f.全域属性: id,tabindex,repeat
g.新的全域属性：contenteditable,contextmenu,draggable,dropzone,hidden,spellcheck
h.移除元素：acronym, applet, basefont, big, center, dir, font, frame, frameset, isindex, noframes, strike, tt
i.新增接口：HTML Geolocation HTML Drag and Drop HTML Local Storage HTML Application Cache
            HTML Web Workers HTML SSE HTML Canvas/WebGL HTML Audio/Video

16.CSS垂直水平居中

17.页面渲染的完整流程
1. 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件； 

2. 浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件； 

3. 浏览器又发出CSS文件的请求，服务器返回这个CSS文件； 

4. 浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了； 

5. 浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； 

6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； 

7. 浏览器发现了一个包含一行Javascript代码的＜script＞标签，赶快运行它； 

8. Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （style.display=”none”）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码； 

9. 终于等到了＜/html＞的到来，浏览器泪流满面…… 

10. 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径； 

11. 浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。


18.用户输入URL回车之后，浏览器都做了哪些？
a.浏览器查找域名的ip地址
b.浏览器给web服务器发送一个HTTP请求
c.网站服务的永久重定向响应
d.浏览器跟踪重定向地址，现在，浏览器知道了要访问的正确地址，所以它会发送另一个获取请求。
e.服务器处理请求，并返回一个响应
f.服务器返回一个HTML响应
g.浏览器开始写显示HTML


19.event作为函数参数

20.（性能优化）函数节流与去都抖动应用场景和原理以及实现方法

21.几个鼠标事件中的坐标总结
clientX:返回鼠标位置相对于浏览器窗口左上角的水平坐标
clientY:返回垂直坐标

movementX:当前位置与上一个mousemove事件之间的水平距离
movementY:当前位置与上一个mousemove事件之间的垂直距离

screenX:返回鼠标位置相对于屏幕左上角的水平坐标
screenY:返回垂直坐标

offsetX:返回鼠标位置与目标节点左侧的padding边缘的水平距离
offsetY:返回与目标节点上方的padding边缘的垂直距离

pageX:返回鼠标位置与文档左侧边缘的距离
pageY:返回鼠标位置与文档上侧边缘的距离

22.new操作符具体都做了些什么
a.创建出了一个对象，并且继承了函数的原型
b.this指向该对象的引用，并且最后隐式地返回this
c.属性和方法被加入到this的引用中

23.一些js命令扫盲
a.$$(sel)//被许多现代浏览器命令行支持，等价于document.querySelectorAll(sel)
b.~~Math.random()*(1<<24) // ~~ 作用相当于 parseInt 取整
c.[].forEach.call(NodeLists)//因为NodeList没有forEach方法，因此借助空数组，并且使用call函数将数组遍历函数forEach应用到元素节点列表

24.CSS中的outline样式属性
outline是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用
该样式位于盒模型之外，不影响元素布局位置

25.CSS3新增元素特性

25.深入理解异步编程（***）
a.回调函数
b.事件监听
c.发布/订阅
d.Promise对象
e.Async函数

26.web开发中回话跟踪的方法有哪些
a.session
b.cookie
c.url重写
d.隐藏inout
e.ip地址

27.javascript如何实现继承
a.类式继承
b.构造函数继承
c.组合继承
d.寄生组合式继承
e.extends继承


28.何为沙盒机制
对应用程序执行各种操作进行了权限的限制，在IOS系统中，一般程序是没有权限访问系统的缓存等

29.CSS选择器

30.回调函数的作用及意义

31.jQuery尺寸验证

32.名词扩写整理
a.DOM   Document Object Model
b.HTML	Hyper Text Model Language
c.CSS   
d.AJAX  Asynchronous Javascript and XML
e.URI Uniform Resource Identifier

33.HTTP请求中 GET和POST的区别
url请求有和区别？


34.页面转发和重定向的区别
URL:重定向开始了一个新的HTTP请求，地址栏会变；转发是服务器内部重定向，地址栏信息不变
数据共享：重定向不能共享请求里的数据；转发则可以共享请求里的数据

35.域名概念学习

36.js创建对象的几种方式

37.何为异步？何为同步？
异步：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，
等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验
（用户填写表单，同时进行表单验证）
同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，
用户看到新内容,进行下一步操作
（用户提交表单后的显示结果的过程）

39.Chrome懒加载资源的机制（总结 记录）

40.深入理解原型链
--原型对象：对于每一个构造函数，都有一个prototype属性，指向一个对象。生成实例的时候，
该属性（prototype）会自动成为实例对象的原型。原型对象的作用，就是定义所有实例对象共享
的属性和方法。实例对象可以视作从原型对象衍生出来的子对象。
--原型链：每个对象都有自己的原型对象，而原型对象也是对象，也有自己的原型，因此构成了原型链。
--属性：读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就去它的原型找，
依此类推，直到最顶层Object.prototype，还是找不到的话，则返回undefined
?
问题：原型链的尽头是null,属性找不到返回undefined?

41.JS中的call,apply和bind方法（！！写一下文档）
是Function自带的三个方法，主要作用是改变函数中的this指向。
call方法和apply方法类似，只是后者需要把参数传入数组中

传入对象的取值有以下4种情况：
（1）不传，或者传null,undefined， 函数中的this指向window对象
（2）传递另一个函数的函数名，函数中的this指向这个函数的引用
（3）传递字符串、数值或布尔类型等基础类型，函数中的this指向其对应的包装对象，如 String、Number、Boolean
（4）传递一个对象，函数中的this指向这个对象

42.null和undefined的区别
（1）null是一个表示“空”的对象，转为数值时为0;undefined是一个表示“此处无定义”的原始值，转为数值时为NaN

43.了解js封装的函数 debounce map foreach等

44.何为严格模式？
目的：消除js语法的不合理之处；使代码运行更加安全；编译更加高效

45.如何判断一个对象是否属于某个类
（1）使用 instance of
（2）object.prototype（？）

46.js哪些操作会造成内存泄漏？（！！浅谈js的垃圾回收机制）
（1）setTimeout的第一个参数使用字符串而非函数
（2）意外的全局变量引起的内存泄漏
（3）闭包
（4）没有清理的DOM元素引用
（5）两个对象相互引用（循环引用）
（6）控制台日志

47.js垃圾回收的方法
（1）标记清除（进入环境、离开环境）
（2）引用计数（引用数为0时，清除该变量）

48.js中的设计模式

49.匿名函数的写法

50.何为js的同源策略？（same-orign policy）
同源：协议相同;域名相同;端口相同
目的：保证用户信息在网络中的安全，防止恶意的网站窃取数据
行为受限：（一）无法读取非同源网页的Cookie LocalStorage IndexedDB
	  （二）无法解除非同源网页的DOM
	  （三）无法向非同源地址发送AJAX请求（可以发送，但浏览器会拒绝接受响应）

设置同源共享Cookie:在两个一级域名相同的网页中设置 document.domain=XX

对于完全不同源的网站，两种方法解决跨域通信的问题
（一）片段识别符
 含义：URL中#后面的部分;它只是改变片段标识符，页面不会重新刷新
父窗口可以把信息，写入子窗口的片段标识符
（二）跨文档通信API
使用方法：window.postMessage	
（三）JSONOP
（四）WebSocket
（五）CORS Cross-Orign Resource Sharing

51.域名？一级域名？二级域名
一级域名：就是在“com net org”前加一段
二级域名：就是在一级域名前再加一段
二级域名及其以上级别的域名，统称为子域名，不在“注册域名”的范畴中


52.HTML去掉超链接的样式

53.前端下载文件的方式

54.后端文件下载

55.defer 和 async

56.script标签的阻塞行为
浏览器在下载、解析、执行脚本的时候不会做页面渲染、响应用户事件之类的事情。因为js脚本可能会做一系列的
DOM操作动作，最关键的还有脚本之间的依赖性，浏览器必须等待当前执行的脚本执行完成之后再进行后续的操作。
（故不支持js的并行下载）

57.了解XHR

58.浏览器的等待标志

59.多个js脚本的执行顺序

61.箭头函数的this指向问题（结合jquery添加自定义验证）
箭头函数没有自己的this上下文
箭头函数的函数体中出现的this在运行时绑定到最近的作用域上下文对象

62.数据库长度对应的字符串长度

63.jquery 表单验证  做校验的时候都发生了什么？
个人理解：jQuery封装好了方法写在了js的函数中，根据对元素添加的验证规则进行校验，
一般是form表单元素中某个事件触发之后，判断其值是否符合规则，不符合的话则提醒相
应的错误信息。

64.自定义事件

65.浏览器无痕模式
并不会在网络中隐藏你发起的请求，只是不在浏览器中保存存储浏览记录乃至cookie

66.less sass scss

67.相对路径  绝对路径

68.魔法数字

=======================================
需要特别熟练掌握的技能
1.文件上传与下载
2.Ajax
3.表单  /  验证
4.git
5.同步/异步
6.正则表达式
7.日期（各种外部js或者jquery库）
8.事件




































1.何为非阻塞方式下载js文件？（和56点相呼应）
a.js文件的加载方式
--使用<script>标签内联到HTML页面
--使用<script>标签的src属性引入外部的js文件

注：并行下载并不意味着并行执行（我们要确保的是执行的正确顺序）

b.非阻塞加载外部脚本
--XHR Eval
使用XMLHTTPRequest对象从服务器异步获取js脚本文件，当响应完成后使用eval函数对响应内容进行执行。

--XHR Injection
将异步获取的内容使用动态创建script标签的形式插入到DOM元素中去。

--Script in IFrame
将需要加载的js脚本放入一个html文件中然后使用iframe非阻塞加载这个html文件即可

--Script DOM Element
通过js脚本动态创建script标签到DOM中，可以动态设置src属性，并且可以是不同域名下的js文件

--Script Defer（仅适用于IE浏览器）
IE浏览器的script标签支持defer属性，表示浏览器不会立即下载这个script标签对应的js文件

2.何为闭包？（浅谈js中的闭包）=> 结合面试题
首先：变量作用域
js作用域的特殊之处：函数内部可以读取全局变量
声明变量时注意：如果在函数内部声明变量不用var，该变量会变成全局变量
链式作用域：父对象的所有变量，对子对象都是可见的，反之则不成立。
总结性概念：闭包就是可以读取其他函数内部变量的函数/函数内部的函数
闭包的用途：可以读取函数的内部变量；让这些变量的值始终保存在内存中

使用闭包注意点：闭包使得函数中的变量长时间存储在内存中，会造成资源浪费
在退出函数之间，将不使用的局部变量全部删除;
会随便改变父函数内部变量的值

3.何为重绘和回流？

重绘：渲染树的元素外观发生改变但不影响布局时，会发生重绘
回流：渲染树的元素布局发生改变时，会引起重绘回流
回流一定会引起重绘，但是重绘不一定会引起回流

4.正则表达式中一些常用的符号
?
+
*

5.作用域与变量声明提升？
作用域：为function(){}内的区域，称为函数作用域
变量声明提升：函数声明与变量声明经常被提升到当前作用域的顶部

6.blob(binary large object)类型的数据--二进制大对象
BLOB数据类型以随机存取块的形式存储任何种类的二进制数据

7.频繁的事件触发有哪些？

8.何为TypeScript
TypeScript是一种由微软开发的自由和开源的编程语言。
它是JavaScript的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。

9.何为作用域链（例子理解）  类似于原型链
a)全局函数无法查看局部函数的全部细节，但局部函数可以查看其上层的函数细节，直至全局细节
b)如果当前作用域没有找到属性或方法，会向上层作用域查找，直至全局函数，这种形式就是作用域链

10.对this对象的理解
a)对于函数，this 指向调用该函数的对象
b)对于事件，this指向触发该事件的对象
c)对于 new 方法，this指向被创建出来的实例对象
d)IE下attachEvent中的this指向全局对象Window

11.复述HTML文档中都有哪些节点
文档节点：整个文档
元素节点：每个HTML元素
文本节点：HTML元素内的文本
属性节点：每个HTML属性
注释节点：注释
根节点：Document对象是HTML文档的根节点

12.事件的三个阶段
捕获阶段、目标阶段、冒泡阶段
浏览器总是假定click事件的目标节点为嵌套最深的那个节点

13.写一个完整的HTML文档的结构
<!DOCTYPE html>
  <head>
    <title></title>
  </head>
  <body></body>
</html>

14.如何引用JQuery库
下载JQuery库 -> 在HTML的<script>标签中引用它
JQuery版本有两种：
Production version - 用于实际的网站中，已被精简和压缩
Development version - 用于测试和开发，代码可读

15.定时器
setTimeout(fn, period);在指点一段时间后执行一次fn函数
setTimeInterval(fn, period);每隔一段制定的时间period执行一次fn函数

16.函数定义的两种方式
a.函数声明  function foo() {}
b.函数表达式（‘=’赋值表达式） var foo = function() {}
另外，还有一种自执行函数表达式，主要用于创建一个新的作用域，在此作用域内声明的变量不会和其他作用域的变量冲突或混淆，
大多是以匿名函数的方式存在，且立即自动执行。
(function(){})();

17.页面渲染的完整流程
1. 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件； 

2. 浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件； 

3. 浏览器又发出CSS文件的请求，服务器返回这个CSS文件； 

4. 浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了； 

5. 浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； 

6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； 

7. 浏览器发现了一个包含一行Javascript代码的＜script＞标签，赶快运行它； 

8. Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （style.display=”none”）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码； 

9. 终于等到了＜/html＞的到来，浏览器泪流满面…… 

10. 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径； 

11. 浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。

18.数据类型？基本数据类型？Primitive数据类型？
5种简单（基本）数据类型：undefined null boolean number string
1种复杂数据类型：Object（包括function array?）
primitive数据类型：char byte short int long float double
typeof操作符（注意不是函数）可以用来检测给定变量的数据类型

19.事件中的浏览器兼容性

20.（性能优化）函数节流与去都抖动应用场景和原理以及实现方法
根据功能实现逻辑……

21.几个鼠标事件中的坐标总结
clientX:返回鼠标位置相对于浏览器窗口左上角的水平坐标
clientY:返回垂直坐标

movementX:当前位置与上一个mousemove事件之间的水平距离
movementY:当前位置与上一个mousemove事件之间的垂直距离

screenX:返回鼠标位置相对于屏幕左上角的水平坐标
screenY:返回垂直坐标

offsetX:返回鼠标位置与目标节点左侧的padding边缘的水平距离
offsetY:返回与目标节点上方的padding边缘的垂直距离

pageX:返回鼠标位置与文档左侧边缘的距离
pageY:返回鼠标位置与文档上侧边缘的距离

22.new操作符具体都做了些什么
a.创建出了一个对象，并且继承了函数的原型
b.this指向该对象的引用，并且最后隐式地返回this
c.属性和方法被加入到this的引用中

23.一些js命令扫盲
a.$$(sel)//被许多现代浏览器命令行支持，等价于document.querySelectorAll(sel)
b.~~Math.random()*(1<<24) // ~~ 作用相当于 parseInt 取整
c.[].forEach.call(NodeLists)//因为NodeList没有forEach方法，因此借助空数组，并且使用call函数将数组遍历函数forEach应用到元素节点列表

24.window对象（定义、属性和方法）

25.深入理解异步编程（***）
a.回调函数
b.事件监听
c.发布/订阅
d.Promise对象
e.Async函数

26.web开发中回话跟踪的方法有哪些
a.session
b.cookie
c.url重写
d.隐藏inout
e.ip地址

27.javascript如何实现继承
a.类式继承
b.构造函数继承
c.组合继承
d.寄生组合式继承
e.extends继承


28.何为沙盒机制
对应用程序执行各种操作进行了权限的限制，在IOS系统中，一般程序是没有权限访问系统的缓存等

29.Node类型（写文章）

30.innerHTML & innerText & outerHTML三者的区别（写文章√）

31.constructor & prototype
32.名词扩写整理
a.DOM   Document Object Model
b.HTML	Hyper Text Model Language
c.CSS   
d.AJAX  Asynchronous Javascript and XML
e.URI Uniform Resource Identifier

34.页面转发和重定向的区别
URL:重定向开始了一个新的HTTP请求，地址栏会变；转发是服务器内部重定向，地址栏信息不变
数据共享：重定向不能共享请求里的数据；转发则可以共享请求里的数据

35.创建对象new命令的原理  构造函数中有return（分情况讨论）

36.js创建对象的几种方式

37.何为异步？何为同步？
异步：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，
等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验
（用户填写表单，同时进行表单验证）
同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，
用户看到新内容,进行下一步操作
（用户提交表单后的显示结果的过程）

38.window.location.protocol window.location.host window.location.href
39.Chrome懒加载资源的机制（总结 记录）

40.深入理解原型链
--原型对象：对于每一个构造函数，都有一个prototype属性，指向一个对象。生成实例的时候，
该属性（prototype）会自动成为实例对象的原型。原型对象的作用，就是定义所有实例对象共享
的属性和方法。实例对象可以视作从原型对象衍生出来的子对象。
--原型链：每个对象都有自己的原型对象，而原型对象也是对象，也有自己的原型，因此构成了原型链。
--属性：读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就去它的原型找，
依此类推，直到最顶层Object.prototype，还是找不到的话，则返回undefined

原型链一般在定义构造函数时用到，可以认为是针对构造函数的或者说是针对构造函数对应的类的。JavaScript没有对应
继承的关键字，所以用原型链模拟继承的效果。

41.JS中的call,apply和bind方法
是Function自带的三个方法，主要作用是改变函数中的this指向。
call方法和apply方法类似，只是后者需要把参数传入数组中
bind……（待续）

传入对象的取值有以下4种情况：
（1）不传，或者传null,undefined， 函数中的this指向window对象
（2）传递另一个函数的函数名，函数中的this指向这个函数的引用
（3）传递字符串、数值或布尔类型等基础类型，函数中的this指向其对应的包装对象，如 String、Number、Boolean
（4）传递一个对象，函数中的this指向这个对象

42.null和undefined的区别
（1）null是一个表示“空”的对象，转为数值时为0;undefined是一个表示“此处无定义”的原始值，转为数值时为NaN

43.了解js封装的函数 debounce map foreach等
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects JavaScript标准库

44.何为严格模式？
目的：消除js语法的不合理之处；使代码运行更加安全；编译更加高效

45.如何判断一个对象是否属于某个类
（1）使用 instance of
（2）object.prototype（？）

46.js哪些操作会造成内存泄漏？（！！浅谈js的垃圾回收机制）
（1）setTimeout的第一个参数使用字符串而非函数
（2）意外的全局变量引起的内存泄漏
（3）闭包
（4）没有清理的DOM元素引用
（5）两个对象相互引用（循环引用）
（6）控制台日志

47.js垃圾回收的方法
（1）标记清除（进入环境、离开环境）
（2）引用计数（引用数为0时，清除该变量）

49.匿名函数的写法

50.何为js的同源策略？（same-orign policy）
同源：协议相同;域名相同;端口相同
目的：保证用户信息在网络中的安全，防止恶意的网站窃取数据
行为受限：（一）无法读取非同源网页的Cookie LocalStorage IndexedDB
	  （二）无法解除非同源网页的DOM
	  （三）无法向非同源地址发送AJAX请求（可以发送，但浏览器会拒绝接受响应）

设置同源共享Cookie:在两个一级域名相同的网页中设置 document.domain=XX

对于完全不同源的网站，两种方法解决跨域通信的问题
（一）片段识别符
 含义：URL中#后面的部分;它只是改变片段标识符，页面不会重新刷新
父窗口可以把信息，写入子窗口的片段标识符
（二）跨文档通信API
使用方法：window.postMessage	
（三）JSONOP
（四）WebSocket
（五）CORS Cross-Orign Resource Sharing

51.二进制文件都有哪些？
http://www.woshipm.com/pmd/804406.html

52.熟悉JS对象的各种方法

53.前端下载文件的方式

54.后端文件下载

55.defer 和 async

56.script标签的阻塞行为
浏览器在下载、解析、执行脚本的时候不会做页面渲染、响应用户事件之类的事情。因为js脚本可能会做一系列的
DOM操作动作，最关键的还有脚本之间的依赖性，浏览器必须等待当前执行的脚本执行完成之后再进行后续的操作。
（故不支持js的并行下载）

57.了解XHR（XMLHTTPRequest）
"我们使用XMLHTTPRequest对象来发送一个Ajax请求"
Ajax的功能是利用XMLHttpRequest对象的属性和方法封装起来的。
它是一组API函数集，可被一些脚本语言使用，通过HTTP协议在浏览器和web服务器之间收发XML或其他数据。
它最大的好处在于可以动态地更新网页，它无需重新从服务器读取整个网页，也不需要安装额外的插件。

58.浏览器的等待标志

59.多个js脚本的执行顺序

60.正则表达式联系
――0到100的二位小数 100为最大
^100$|^[1-9]?\d(\.\d\d?)?$
――身份证校验
^\d{15}$|^\d{18}$|^\d{17}(\d|x|X)$

61.箭头函数的this指向问题
箭头函数没有自己的this上下文
箭头函数的函数体中出现的this在运行时绑定到最近的作用域上下文对象

62.数据库长度对应的字符串长度

63.JavaScript没有独立的运行窗口，浏览器的当前窗口就是它的运行窗口。
64.自定义事件（参考已有代码总结）
a.自定义一个事件
b.给元素绑定事件
c.触发事件

65.浏览器无痕模式
并不会在网络中隐藏你发起的请求，只是不在浏览器中保存存储浏览记录乃至cookie

66.Ajax中JavaScript脚本缓存问题
修改JS内容，调试时并不能显示新写的代码的结果，是因为JS为了加速页面执行，当前页面会使用缓存来保持当前调用的相同连接。

为了开发时调试方便，可以在链接地址的后面增加一个随机函数。

67.相对路径  绝对路径
绝对路径：从文件根目录逐级往下的文件路径
相对路径：从当前文件出发的相对于目标文件的路径

/ : 表示根目录
../ ： 表示向上退一级

68.魔法数字
在代码中含义不明的数字，阅读上难以理解

69.简述Ajax的优缺点
优点：
（1）页面无刷新，用户体验好
（2）使用异步方式与服务器通信，具有更加迅速的响应能力
（3）可以把以前一些服务器负担的工作转嫁到客户端，利用客户端 闲置的能力来处理，减轻服务器和带宽德的负担，
节约空间和带宽租用成本。
（4）基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。

缺点：
（1）不支持浏览器返回按钮
（2）对搜索引擎的支持比较弱
（3）安全问题，暴露了与服务器交互的细节
（4）破坏了程序的异常机制
（5）不容易调试

70.font-size:62.5%，如此设计字体大小的原因（继续确认）
主要是为了方便em和px的相互转换，em初始值为1em=16px,这样的话，1.2em=19.2px，可是我们在设计时很少见到这样表示的大小，
也就是说，在用px表示大小时，数值是不带小数位的。

71.为什么用多个域名来存储网站资源会更有效？
（1）CDN缓存更方便
（2）突破浏览器并发限制
（3）节约cookie带宽
（4）节约主域名的连接数，优化页面响应速度
（5）防止不必要的安全问题

72.cookie&localStorage&sessionStorage三者的区别
A:cookie   B:localStorage   C:sessionStorage
（1）存储位置:A存储在客户端本地文件中，B&C则存储在浏览器中
（2）时效：A根据所设定的过期时长来判断是否有效，B长期有效，需要手动进行删除，C则存在于一次回话中，当前浏览器关闭，则自动被删除
（3）与服务器交互：A每次都会通过HTTP请求发送到服务器，用来表明自己的身份
（4）数据大小：A不能超过4KB，B&C可以达到5M或者更大
（5）作用域：C不能在不同的浏览器窗口间共享，即使是同一个页面。B在所有同源窗口中都是共享的。A也是在所有同源窗口中共享。

WebStorage支持事件通知机制，可以将数据更新的通知发送给监听者。WebStorage的API接口使用更方便。


73.编写Ajax的四个主要步骤
（1）创建Ajax对象
（2）编写回调函数
（3）建立一个url请求
（4）发送数据

74.HTTP请求中get和post的区别
（1）应用场景：
（2）url格式
（3）请求数据大小
（4）编码格式
（5）请求信息存放位置

75.用for-in 循环数组得到的是数组的value值

76.数组相关的方法
unshift() --在数组的开始处插入一个或多个元素
map() --对数组中的每一个元素按照给定函数进行加工处理，并返回一个新数组
reverse() --翻转数组
find() --根据参数函数中的条件返回符合的第一个元素

77.JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype），使用构造函数（constructor）作为对象的模板。

78.实现0和1互换的方法
~：按位取反运算符
所有正整数的按位取反是其本身+1的负数
所有负整数的按位取反是其本身+1的绝对值
零的按位取反是-1

79.深链接的概念
https://blog.csdn.net/linguifa/article/details/3922951

80.Javascript中的集合类（特征以及遍历方法）
Array() 传统数组（下标访问） 关联数组（数组对象的属性）
Map() 一组键值对的结构，存放该数据结构的集合，键的类型不只局限于字符串，各种类型的值都可以当做键
Set() 类似于数组，是一组key的集合，但不存储value，key不能重复，（或者可以说键名和键值是同一个值）
利用这一属性可以实现数组去重（构造器新建set实例）
方法: return Array.from(new Set(array))
WeakSet 类似于Set，但是成员只能是对象，其中的对象都是弱引用，适合临时存放一组对象，因为成员随时都会消失，
故Weakset类型的数据不可遍历。
WeakMap 就有和WeakSet类似的特征


81.Javascript 和 Typescript的区别
JS所具有的一些特性：不访问本地磁盘数据；在浏览器上运行，与操作系统无关，是跨平台的；
是事件驱动的；是由网景开发的



82.表单中的文件数据流处理

83.设计模式
观察者模式：
单例模式：
工厂模式

84.Object.assign()
Object.keys()
85.es6中的Promise

86.es6中的import和export写法总结

87.JSON.parse() 与 JSON.stringify()
JSON.parse()   将符合JSON格式的字符串转化为对象,形如数组的，则转化问数组
JSON.stringify() 将对象转为字符串
（方法中的参数后续了解……）
注意：Javascript对象的键必须是字符串

88.扩展运算符
将一个数组转为用逗号分隔的参数序列

89.弱引用
垃圾回收机制不考虑对该对象的引用

90.修饰器
修饰器对类的行为、属性的特性的改变，是代码编译时发生，而不是在运行时。修饰器本质就是编译时执行的函数
如果同一个方法有多个修饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行

91.Javascript中预编译和执行过程
一、编译阶段
(a)词法分析 将字节流转换为记号流，就像英文句子一个个单词独立翻译
(b)语法分析 得到语法树，当Javascript解释器在构造语法树的时候，如果发现无法构造，就会报语法错误，并结束整个代码块的解析
(c)预编译（并非完全的顺序执行）当JavaScript引擎解析脚本时，它会在预编译期对所有声明的变量和函数进行处理！并且是先预声明变量，再预定义函数！

二、执行阶段
在解释过程中，JavaScript引擎是严格按着作用域机制（scope）来执行的。JavaScript语法采用的是词法作用域（lexcical scope），
也就是说JavaScript的变量和函数作用域是在定义时决定的，而不是执行时决定的，由于词法作用域取决于源代码结构，
所以 JavaScript解释器只需要通过静态分析就能确定每个变量、函数的作用域，这种作用域也称为静态作用域（static scope）。
补充：但需要注意，with和eval的语义无法仅通过静态技术实现，实际上，只能说JS的作用域机制非常接近lexical scope。

JavaScript引擎在执行每个函数实例时，都会创建一个执行环境（execution context）。执行环境中包含一个调用对象（call object）, 
调用对象是一个scriptObject结构（“运行期上下文”），用来保存内部变量表varDecls、内嵌函数表funDecls、父级引用列表upvalue等语法分析结构
（注意：varDecls和funDecls等信息是在语法分析阶段就已经得到，并保存在语法树中。函数实例执行时，会将这些信息从语法树复制到 scriptObject上）。
scriptObject是与函数相关的一套静态系统，与函数实例的生命周期保持一致，函数执行完毕，该对象销毁。

JavaScript引擎通过作用域链（scope chain）把多个嵌套的作用域串连在一起，并借助这个链条帮助JavaScript解释器检索变量的值。
这个作用域链相当于一个索引表，并通过编号来存储它们的嵌套关系。当JavaScript解释器检索变量的值，会按着这个索引编号进行快速查找，
直到找到全局对象（global object）为止，如果没有找到值，则传递一个特殊的undefined值。

<<<<<<< HEAD
92.前端在什么场景会出现乱码的问题，如何解决？
对于字符不同的字符集有不同的编码和解码的规则
如果在某一处是用A字符集进行编码，到了另一个软件上使用B字符集的方式进行解码，就会发生乱码的问题。
总结就是：编码不一致，可能会出现在网页显示编码、网页存储编码或数据库编码其中的环节中
因为文字存储是按照一定的格式进行存储的，一个码代表一个字符（例如ASCII码）

如何解决：保持编码一致，前后端也要注重编码统一

延伸：如果HTML不指定的话，浏览器会使用本地操作系统的字符集，如果应用支持多国语言的话，就会有问题
（本地字符集中没有该字符的解码方式）
	
93.异步加载Javascript的方式

94.为元素绑定多个事件及触发顺序

95.window.onload()和document.ready()的区别

96.Javascript继承是如何工作的？（P124）

97.Javascript中的异常机制
=======
92.export语法
个人理解：就是把一个文件中的变量，函数，文件，模块等暴露出去，使得别的文件可以用import这个关键字来获取到
export加/不加 default两者的区别（↓↓）
在一个问价或模块中，export、import可以有多个，export default仅可以有一个
在文件中导入的方式也不一样 没加default的内容，要用{}括起来，加了default的内容，不用括起来
export和export default 可以同时在一个文件中吗？
可以。但是要注意的是，在一个模块中，export default在一个模块只允许向外暴露一次

93.npm 和 webpack的概念
webpack 是一个现代的 JavaScript 应用程序的模块打包器(module bundler)。

webpack:模块之间相互独立又相互依赖
webpack 通过 loader 可以支持各种语言和预处理器编写模块。
webpack 是高度可配置的，如何模块化打包、加载都可以基于配置文件定制。
webpack 的默认配置文件是 webpack.config.js。
webpack 从命令行或配置文件中定义的一个模块列表开始，处理你的应用程序。 从这些入口起点开始，webpack 递归地构建一个依赖图表，
这个依赖图表包含着应用程序所需的每个模块，然后将所有这些模块打包为少量的 bundle- 通常只有一个 - 可由浏览器加载。

webpack 把每个文件(.css, .html, .scss, .jpg, etc.) 都作为模块处理。然而 webpack 只理解 JavaScript。
webpack loader 会将这些文件转换为模块，而转换后的文件会被添加到依赖图表中。

npm:包管理工具

>>>>>>> deeb7042627b4da29026670350839dabf22a52c6
=======================================
需要特别熟练掌握的技能
1.文件上传与下载
2.Ajax
3.表单  /  验证
4.git
5.同步/异步
6.正则表达式
7.日期（各种外部js或者jquery库）
8.事件
9.时区问题
10.用户验证


































